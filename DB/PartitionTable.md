# Partition Table

데이터베이스 테이블의 데이터들이 너무 많아서 어떤 데이터를 조회하려고 할 때 시간이 너무 많이 소요된다면 어떻게 해야 할까요?
이것을 개선할 수 있는 많은 방법이 있겠지만 파티션 테이블로 만드는 방법도 좋은 방법이 될 수 있습니다.

파티션 테이블은 **논리적으로는 하나의 테이블**이지만 **물리적으로는 여러 개의 파티션으로 나뉘어 데이터들이 각각의 세그먼트에 저장되는 테이블**이라고 생각하시면 됩니다.
파티션 테이블에는 **Pruning**이라는 기능이 있어서 특정 데이터를 조회를 할 때 그 데이터가 속해있는 세그먼트만 빠르게 조회할 수 있는 기능이 있습니다. 

파티션 테이블은 **데이터의 양이 많고 INSERT가 지속적으로 일어나는 테이블**만 파티션 테이블로 지정해주는 것이 좋습니다. 예를 들자면 로그가 저장되는 테이블이나 주문기록을 저장하는 테이블 등이 대상이 됩니다.

### 파티셔닝 전략

1. 수직 분할 (vertical partitioning)
- 테이블 컬럼을 기준으로 나누는 기법
- 자주 사용하는 컬럼을 분리시켜 성능 향상
   
2. 수평 분할 (horizontal partitioning)
- 데이터 개수를 기준으로 나누고 이를 통해 인덱스 성능을 향상을 기대하는 방법

### 종류 (분할 기준)

![image](https://github.com/user-attachments/assets/97d71811-72ed-40f3-9f46-1bf44f1d666c)

1. 범위 분할 (range partitioning)
- 일, 월, 분기 등 특정 컬럼의 정렬 값을 기준으로 분할하는 방식.
- 분할 키 값이 범위 내에 있는지 여부로 구분한다.
- 우편 번호, 날짜 등의 데이터에 적합하다.
- 범위가 포함하는 데이터의 양이 일정하지 않은 경우 특정 파티션에 대해 데이터가 편중될 수 있다.

2. 목록 분할 (list partitioning)
- 키 컬럼 값을 기준으로 파티션 하는 방식.
- 여러 컬럼으로 파티션 키를 생성할 수 없고 오직 하나의 컬럼만 가능하다.
- 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능하다.
- 분포도가 비슷하며, 많은 SQL에서 해당 칼럼의 조건이 많이 들어오는 경우 유용하다.

3. 해시 분할 (hash partitioning)
- 파티션 키(Key)의 해시 값에 의한 파티셔닝이 이루어진다.
- 균등한 데이터 분할이 가능하다.
- 특정 데이터가 어느 Hash 파티션에 있는지 판단하기 어렵다.
- 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정한다.
- 파티션을 위한 범위가 없는 데이터에 적합하다.

4. 합성 분할 (composite partitioning)
- 위의 분할들을 결합하는 것을 의미한다. 즉, 파티션의 sub-partitioning을 뜻한다.
- 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산할 수 있다.
- 단 이렇게 구성할 경우 파티션을 나누는 기준이 두개가 되기 때문에 파티션의 갯수가 너무 많아지게 됨 (주 파티션의 갯수 X 서브파티션의 갯수) 인덱스의 경합이 너무 심해져서 잘 사용하지는 않는다.

# Before Interview

#### You should know

| Data Structure | Algorithm | Concept |
| ----- | ----- | ----- |
| 연결리스트 (Linked List) | 너비 우선 탐색 (Breadth-First Search) | 비트 조작 (Bit Manipulation) |
| Tree/Tries/Graph | 깊이 우선 탐색 (Depth-First Search) | Memory (Stack vs Heap) |
| Stack | 이진 탐색 (Binary Search) | Recursion |
| Queue | 병합 정렬 (Merge Sort) | Dynamic programming |
| Vector/ArrayList | 퀵 정렬 (Quick Sort) | Big-O |
| Hash Table | | | |

위의 주제에 대해 사용법, 구현법, 그리고 가능하다면 공간과 시간 복잡도에 대해 알아두는 것이 좋습니다.

:paperclip: **자료구조와 알고리즘의 경우, 빈 종이에서부터 즉 밑바닥부터 구현이 가능하도록 연습해두는 것이 좋습니다.**

--- 

#### 빅오 표기법 (Big-O)
  - O(1): 일정한 복잡도 (constant complexity) 혹은 상수 시간 복잡도라고 하며 입력값이 증가해도 수행 시간이 증가하지 않는다.
  예) 해시 테이블에서 요소를 찾는 경우
  - O(logN): 로그 복잡도. 연산이 실행될 때마다 데이터 크기는 절반으로 감소, 입력 크기에 비례하여 로그에 시간이 소요된다
  예) 이진 검색, 힙 정렬
  - O(N): 선형 복잡도. 입력값에 비례하여 선형적으로 복잡도가 증가한다.
  예) 원하는 값을 찾기 위해 검색 범위를 절반씩 줄여나감. 단일 loop 등
  - O(NlogN): 선형 로그 시간 복잡도. 전체 데이터를 원소 하나의 리스트 n개로 만들고 리스트를 두 개씩 합치는 과정을 반복하여 연산
  예) 병합 정렬, 퀵 정렬, 분할 정복 알고리즘
  - O(N^2): 2차 복잡도. 입력값이 증가함에 따라 n 의 제곱만큼 증가한다.
  예) 버블 정렬, 선택 정렬, 2중 for문
  - O(2^N): 지수 시간 복잡도. 완전 탐색과 같이 모든 가능한 조합을 시도하는 경우. 사용 가능한 모든 경우의 수를 탐색하는 경우 가장 느리다.

시간복잡도 크기를 순서대로 나열하면 아래와 같다

O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N)

---

#### :pushpin: 어떤 코드가 좋아 보이나

- 정확도: 에상 가능한 혹은 불가한 입력에 대해서, 코드는 정확히 동작해야 한다
- 효율성: 시간과 공간 두 가지 측면에서 모두 효율성이 좋은 코드여야 한다. (알지만 느무 어려운 것...)
- 간략화: 코드 100줄 짜리를 10줄로 작성할 수 있다면! *물론 충분한 검증이 수반되어야 한다*
- 가독성: 필요한 곳엔 주석을 아끼지 말자. 다른 개발자들도 코드를 읽고 어떻게 동작하는지 이해할 수 있어야 한다.
- 관리 가능성: 코드는 제품의 수명주기 동안에 적절히 수정 가능해야 하고, 최초로 작성한 개발자뿐만 아니라 다른 개발자도 쉽게 관리 가능한 코드여야 한다.
